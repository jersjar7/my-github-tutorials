<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eigenvalues & Eigenvectors - Linear Algebra</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .header h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            color: #FFD700;
        }
        
        .header .breadcrumb {
            font-size: 1em;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .header .description {
            font-size: 1.2em;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-icon {
            font-size: 1.2em;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .matrix-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .matrix {
            position: relative;
            display: inline-block;
            padding: 15px 5px;
        }
        
        .matrix::before,
        .matrix::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            border: 3px solid #333;
        }
        
        .matrix::before {
            left: 0;
            border-right: none;
        }
        
        .matrix::after {
            right: 0;
            border-left: none;
        }
        
        .matrix-grid {
            display: grid;
            gap: 5px;
            padding: 0 10px;
        }
        
        .matrix-cell {
            width: 60px;
            height: 40px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            font-size: 16px;
            background: white;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .matrix-cell input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 14px;
            background: transparent;
            color: #333;
        }
        
        .matrix-cell input:focus {
            outline: 2px solid #4CAF50;
            background: #f0f8ff;
        }
        
        .matrix-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            color: #333;
            font-size: 18px;
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            color: #333;
        }
        
        .canvas-container h3 {
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            background: white;
            cursor: crosshair;
        }
        
        .eigenvalue-result {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .eigenvalue-result h4 {
            color: #2196F3;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .eigenvalue-item {
            background: rgba(33, 150, 243, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid #2196F3;
        }
        
        .eigenvalue-item strong {
            color: #1976D2;
        }
        
        .eigenvector-display {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        
        .btn-warning {
            background: linear-gradient(45deg, #FF9800, #f57c00);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }
        
        .btn-purple {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .concept-explanation {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #FFD700;
            margin-bottom: 20px;
        }
        
        .concept-explanation h4 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .concept-explanation p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 10px 0;
            font-size: 1.1em;
        }
        
        .transformation-viz {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .transformation-viz h4 {
            color: #2196F3;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .pca-demo {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .pca-demo h4 {
            color: #9C27B0;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .data-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .data-controls label {
            font-weight: 500;
        }
        
        .data-controls input[type="range"] {
            width: 100px;
            margin: 0 5px;
        }
        
        .pca-results {
            background: rgba(156, 39, 176, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #9C27B0;
        }
        
        .ml-application {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .ml-application h4 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .practice-section {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }
        
        .practice-section h3 {
            color: #FFD700;
            margin-bottom: 15px;
        }
        
        .exercise {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .exercise-question {
            font-weight: 500;
            margin-bottom: 15px;
        }
        
        .exercise-input {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .highlighted-eigenvector {
            stroke: #FF6B6B !important;
            stroke-width: 4 !important;
            fill: #FF6B6B !important;
        }
        
        .transformation-animation {
            position: relative;
        }
        
        .animation-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }
        
        @media (max-width: 1024px) {
            .content-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .matrix-container {
                flex-direction: column;
                gap: 15px;
            }
            
            .matrix-cell {
                width: 50px;
                height: 35px;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .matrix-cell {
                width: 45px;
                height: 30px;
                font-size: 12px;
            }
            
            .controls, .data-controls {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="breadcrumb">🤖 ML Preparation › 📊 Linear Algebra › 🎯 Eigenvalues & Eigenvectors</div>
            <h1>Eigenvalues & Eigenvectors</h1>
            <p class="description">
                The crown jewel of linear algebra! Eigenvalues and eigenvectors reveal the "natural directions" of matrix transformations and unlock the secrets of Principal Component Analysis (PCA), data compression, and dimensionality reduction. Master these concepts to understand the mathematical foundation of modern machine learning.
            </p>
        </div>
        
        <div class="content-grid">
            <div class="section">
                <h2><span class="section-icon">🎯</span>Eigenvalue Calculator</h2>
                
                <div class="matrix-container">
                    <div class="matrix">
                        <div class="matrix-label">Matrix A</div>
                        <div class="matrix-grid" style="grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);">
                            <div class="matrix-cell"><input type="number" id="a11" value="3" step="0.1"></div>
                            <div class="matrix-cell"><input type="number" id="a12" value="1" step="0.1"></div>
                            <div class="matrix-cell"><input type="number" id="a21" value="0" step="0.1"></div>
                            <div class="matrix-cell"><input type="number" id="a22" value="2" step="0.1"></div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn" onclick="calculateEigenvalues()">Find Eigenvalues</button>
                    <button class="btn btn-secondary" onclick="calculateEigenvectors()">Find Eigenvectors</button>
                    <button class="btn btn-warning" onclick="symmetricMatrix()">Symmetric Matrix</button>
                    <button class="btn btn-danger" onclick="randomMatrix()">Random Matrix</button>
                </div>
                
                <div class="eigenvalue-result" id="eigenResults">
                    <h4>Eigenvalue Analysis</h4>
                    <p>Click "Find Eigenvalues" to solve the characteristic equation det(A - λI) = 0</p>
                </div>
                
                <div class="concept-explanation">
                    <h4>The Eigenvalue Equation</h4>
                    <div class="formula">Av = λv</div>
                    <p>Where:</p>
                    <p>• <strong>A</strong> is the matrix</p>
                    <p>• <strong>v</strong> is an eigenvector (direction that doesn't change)</p>
                    <p>• <strong>λ</strong> is an eigenvalue (scaling factor)</p>
                </div>
                
                <div class="concept-explanation">
                    <h4>Characteristic Equation</h4>
                    <div class="formula">det(A - λI) = 0</div>
                    <p>For 2×2: det([a-λ, b; c, d-λ]) = (a-λ)(d-λ) - bc = 0</p>
                    <p>This gives us a polynomial whose roots are the eigenvalues!</p>
                </div>
            </div>
            
            <div class="section">
                <h2><span class="section-icon">🔄</span>Transformation Visualizer</h2>
                
                <div class="transformation-viz">
                    <h4>See Eigenvectors in Action</h4>
                    <canvas id="transformationCanvas" width="400" height="300"></canvas>
                    <p style="font-size: 0.9em; text-align: center; margin-top: 10px; color: #666;">
                        Red vectors are eigenvectors - they only get scaled, never rotated!
                    </p>
                </div>
                
                <div class="controls">
                    <button class="btn btn-secondary" onclick="showTransformation()">Apply Transformation</button>
                    <button class="btn btn-purple" onclick="animateTransformation()">Animate</button>
                    <button class="btn btn-warning" onclick="resetTransformation()">Reset</button>
                    <button class="btn" onclick="showEigenvectors()">Highlight Eigenvectors</button>
                </div>
                
                <div class="concept-explanation">
                    <h4>Geometric Interpretation</h4>
                    <p>Eigenvectors are special directions that remain unchanged under matrix transformation!</p>
                    <p>• Normal vectors get rotated AND scaled</p>
                    <p>• Eigenvectors only get scaled by their eigenvalue</p>
                    <p>• This reveals the "natural axes" of the transformation</p>
                </div>
                
                <div class="ml-application">
                    <h4>🤖 ML Connection: PCA Preview</h4>
                    <p>In PCA, eigenvectors of the covariance matrix become the principal components!</p>
                    <p>They point in directions of maximum variance in your data.</p>
                </div>
            </div>
        </div>
        
        <div class="content-grid">
            <div class="section">
                <h2><span class="section-icon">📊</span>Principal Component Analysis Demo</h2>
                
                <div class="pca-demo">
                    <h4>Interactive PCA Visualization</h4>
                    <canvas id="pcaCanvas" width="400" height="300"></canvas>
                    
                    <div class="data-controls">
                        <label>Data Spread X:</label>
                        <input type="range" id="spreadX" min="0.5" max="3" step="0.1" value="2">
                        <span id="spreadXValue">2.0</span>
                        
                        <label>Data Spread Y:</label>
                        <input type="range" id="spreadY" min="0.5" max="3" step="0.1" value="1">
                        <span id="spreadYValue">1.0</span>
                        
                        <label>Correlation:</label>
                        <input type="range" id="correlation" min="-0.9" max="0.9" step="0.1" value="0.7">
                        <span id="correlationValue">0.7</span>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-purple" onclick="generateData()">Generate Data</button>
                        <button class="btn" onclick="runPCA()">Run PCA</button>
                        <button class="btn btn-secondary" onclick="projectData()">Project to PC1</button>
                        <button class="btn btn-warning" onclick="clearPCA()">Clear PCA</button>
                    </div>
                    
                    <div class="pca-results" id="pcaResults">
                        <strong>PCA Results:</strong><br>
                        Click "Run PCA" to find principal components and explained variance.
                    </div>
                </div>
                
                <div class="concept-explanation">
                    <h4>PCA Process</h4>
                    <p>1. <strong>Center the data:</strong> Subtract mean from each feature</p>
                    <p>2. <strong>Compute covariance matrix:</strong> C = (1/n)XᵀX</p>
                    <p>3. <strong>Find eigenvectors of C:</strong> These are principal components</p>
                    <p>4. <strong>Sort by eigenvalues:</strong> Larger eigenvalue = more variance</p>
                    <div class="formula">PC1 = eigenvector with largest eigenvalue</div>
                </div>
                
                <div class="ml-application">
                    <h4>🤖 ML Applications</h4>
                    <p><strong>Dimensionality Reduction:</strong> Keep top-k principal components</p>
                    <p><strong>Data Visualization:</strong> Project high-D data to 2D/3D</p>
                    <p><strong>Noise Removal:</strong> Remove components with small eigenvalues</p>
                    <p><strong>Feature Engineering:</strong> Create uncorrelated features</p>
                </div>
            </div>
            
            <div class="section">
                <h2><span class="section-icon">🧮</span>Step-by-Step Calculation</h2>
                
                <div class="eigenvalue-result" id="stepByStep">
                    <h4>Manual Calculation Process</h4>
                    <p>Let's work through finding eigenvalues for a 2×2 matrix step by step:</p>
                    
                    <div class="eigenvalue-item">
                        <strong>Step 1:</strong> Set up characteristic equation<br>
                        <div class="formula">det(A - λI) = det([a-λ, b; c, d-λ]) = 0</div>
                    </div>
                    
                    <div class="eigenvalue-item">
                        <strong>Step 2:</strong> Expand determinant<br>
                        <div class="formula">(a-λ)(d-λ) - bc = 0</div>
                    </div>
                    
                    <div class="eigenvalue-item">
                        <strong>Step 3:</strong> Solve quadratic equation<br>
                        <div class="formula">λ² - (a+d)λ + (ad-bc) = 0</div>
                    </div>
                    
                    <div class="eigenvalue-item">
                        <strong>Step 4:</strong> For each λ, find eigenvector<br>
                        <div class="formula">(A - λI)v = 0</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn btn-secondary" onclick="showDetailedCalculation()">Show Current Matrix Calculation</button>
                    <button class="btn btn-purple" onclick="showQuadraticFormula()">Quadratic Formula</button>
                </div>
                
                <div class="concept-explanation">
                    <h4>Key Properties</h4>
                    <p>• <strong>Trace:</strong> Sum of eigenvalues = sum of diagonal elements</p>
                    <p>• <strong>Determinant:</strong> Product of eigenvalues = det(A)</p>
                    <p>• <strong>Real symmetric matrices:</strong> Always have real eigenvalues</p>
                    <p>• <strong>Orthogonal eigenvectors:</strong> For symmetric matrices</p>
                </div>
                
                <div class="concept-explanation">
                    <h4>Special Cases</h4>
                    <p>• <strong>λ = 0:</strong> Matrix is singular (not invertible)</p>
                    <p>• <strong>λ > 0:</strong> Eigenvector gets stretched</p>
                    <p>• <strong>λ < 0:</strong> Eigenvector gets flipped and scaled</p>
                    <p>• <strong>|λ| > 1:</strong> Direction grows under repeated transformation</p>
                </div>
            </div>
        </div>
        
        <div class="section full-width">
            <h2><span class="section-icon">🎯</span>Practice Exercises</h2>
            <div class="practice-section">
                <h3>Master Eigenvalues & Eigenvectors</h3>
                
                <div class="exercise">
                    <div class="exercise-question">1. For matrix A = [4, 0; 0, 2], what are the eigenvalues?</div>
                    <div class="exercise-input">
                        <span>λ₁ = </span>
                        <input type="number" id="ex1_lambda1" placeholder="?" style="width: 60px; text-align: center;">
                        <span>λ₂ = </span>
                        <input type="number" id="ex1_lambda2" placeholder="?" style="width: 60px; text-align: center;">
                        <button class="btn" onclick="checkExercise1()">Check</button>
                        <span id="ex1_feedback"></span>
                    </div>
                    <p style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                        Hint: For diagonal matrices, eigenvalues are the diagonal entries!
                    </p>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">2. If vector (1, 0) is an eigenvector of A with eigenvalue 3, what is A(1, 0)?</div>
                    <div class="exercise-input">
                        <span>A(1, 0) = (</span>
                        <input type="number" id="ex2_x" placeholder="?" style="width: 50px; text-align: center;">
                        <span>, </span>
                        <input type="number" id="ex2_y" placeholder="?" style="width: 50px; text-align: center;">
                        <span>)</span>
                        <button class="btn" onclick="checkExercise2()">Check</button>
                        <span id="ex2_feedback"></span>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">3. For PCA, which principal component explains the most variance?</div>
                    <div class="exercise-input">
                        <button class="btn" onclick="checkExercise3('pc1')">PC1 (largest eigenvalue)</button>
                        <button class="btn btn-secondary" onclick="checkExercise3('pc2')">PC2 (smallest eigenvalue)</button>
                        <span id="ex3_feedback"></span>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">4. True or False: Eigenvectors change direction under matrix transformation.</div>
                    <div class="exercise-input">
                        <button class="btn" onclick="checkExercise4(true)">True</button>
                        <button class="btn btn-secondary" onclick="checkExercise4(false)">False</button>
                        <span id="ex4_feedback"></span>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">5. If eigenvalues of a 2×2 matrix are 5 and 2, what is the determinant?</div>
                    <div class="exercise-input">
                        <span>det(A) = </span>
                        <input type="number" id="ex5_det" placeholder="?" style="width: 60px; text-align: center;">
                        <button class="btn" onclick="checkExercise5()">Check</button>
                        <span id="ex5_feedback"></span>
                    </div>
                    <p style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                        Hint: det(A) = product of eigenvalues
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Current matrix values
        let currentMatrix = [[3, 1], [0, 2]];
        let eigenvalues = [];
        let eigenvectors = [];
        let dataPoints = [];
        let pcaComponents = [];
        
        // Canvas contexts
        const transformCanvas = document.getElementById('transformationCanvas');
        const transformCtx = transformCanvas.getContext('2d');
        const pcaCanvas = document.getElementById('pcaCanvas');
        const pcaCtx = pcaCanvas.getContext('2d');
        
        function updateMatrix() {
            currentMatrix[0][0] = parseFloat(document.getElementById('a11').value) || 0;
            currentMatrix[0][1] = parseFloat(document.getElementById('a12').value) || 0;
            currentMatrix[1][0] = parseFloat(document.getElementById('a21').value) || 0;
            currentMatrix[1][1] = parseFloat(document.getElementById('a22').value) || 0;
        }
        
        function calculateEigenvalues() {
            updateMatrix();
            const a = currentMatrix[0][0];
            const b = currentMatrix[0][1];
            const c = currentMatrix[1][0];
            const d = currentMatrix[1][1];
            
            // Characteristic polynomial: λ² - (a+d)λ + (ad-bc) = 0
            const trace = a + d;
            const det = a * d - b * c;
            
            // Quadratic formula
            const discriminant = trace * trace - 4 * det;
            
            if (discriminant >= 0) {
                const sqrtDisc = Math.sqrt(discriminant);
                eigenvalues = [
                    (trace + sqrtDisc) / 2,
                    (trace - sqrtDisc) / 2
                ];
            } else {
                eigenvalues = [
                    { real: trace / 2, imag: Math.sqrt(-discriminant) / 2 },
                    { real: trace / 2, imag: -Math.sqrt(-discriminant) / 2 }
                ];
            }
            
            displayEigenvalues();
        }
        
        function displayEigenvalues() {
            const result = document.getElementById('eigenResults');
            
            let content = '<h4>Eigenvalue Analysis</h4>';
            
            if (typeof eigenvalues[0] === 'number') {
                content += `
                    <div class="eigenvalue-item">
                        <strong>λ₁ = ${eigenvalues[0].toFixed(3)}</strong><br>
                        Scaling factor for first eigenvector
                    </div>
                    <div class="eigenvalue-item">
                        <strong>λ₂ = ${eigenvalues[1].toFixed(3)}</strong><br>
                        Scaling factor for second eigenvector
                    </div>
                `;
                
                const a = currentMatrix[0][0];
                const d = currentMatrix[1][1];
                const det = currentMatrix[0][0] * currentMatrix[1][1] - currentMatrix[0][1] * currentMatrix[1][0];
                
                content += `
                    <div class="eigenvalue-item">
                        <strong>Verification:</strong><br>
                        Trace = λ₁ + λ₂ = ${(eigenvalues[0] + eigenvalues[1]).toFixed(3)} = ${(a + d).toFixed(3)} ✓<br>
                        Det = λ₁ × λ₂ = ${(eigenvalues[0] * eigenvalues[1]).toFixed(3)} = ${det.toFixed(3)} ✓
                    </div>
                `;
            } else {
                content += `
                    <div class="eigenvalue-item">
                        <strong>Complex Eigenvalues</strong><br>
                        λ₁ = ${eigenvalues[0].real.toFixed(3)} + ${eigenvalues[0].imag.toFixed(3)}i<br>
                        λ₂ = ${eigenvalues[1].real.toFixed(3)} + ${eigenvalues[1].imag.toFixed(3)}i<br>
                        This matrix causes rotation + scaling!
                    </div>
                `;
            }
            
            result.innerHTML = content;
        }
        
        function calculateEigenvectors() {
            calculateEigenvalues();
            
            if (typeof eigenvalues[0] !== 'number') {
                alert('Complex eigenvalues detected! Eigenvectors would be complex.');
                return;
            }
            
            eigenvectors = [];
            
            eigenvalues.forEach((lambda, i) => {
                // Solve (A - λI)v = 0
                const a = currentMatrix[0][0] - lambda;
                const b = currentMatrix[0][1];
                const c = currentMatrix[1][0];
                const d = currentMatrix[1][1] - lambda;
                
                let v;
                if (Math.abs(b) > 0.001) {
                    // Use first row: (a-λ)x + by = 0, so y = -(a-λ)x/b
                    v = [1, -a / b];
                } else if (Math.abs(c) > 0.001) {
                    // Use second row: cx + (d-λ)y = 0, so x = -(d-λ)y/c
                    v = [-d / c, 1];
                } else {
                    // Special case - likely identity or scaled identity
                    v = i === 0 ? [1, 0] : [0, 1];
                }
                
                // Normalize
                const norm = Math.sqrt(v[0] * v[0] + v[1] * v[1]);
                v = [v[0] / norm, v[1] / norm];
                
                eigenvectors.push(v);
            });
            
            displayEigenvectors();
            drawTransformationVisualization();
        }
        
        function displayEigenvectors() {
            const result = document.getElementById('eigenResults');
            let content = result.innerHTML;
            
            content += '<h4 style="margin-top: 20px; color: #9C27B0;">Eigenvectors</h4>';
            
            eigenvectors.forEach((v, i) => {
                content += `
                    <div class="eigenvalue-item">
                        <strong>v₁${i+1} = [${v[0].toFixed(3)}, ${v[1].toFixed(3)}]</strong><br>
                        Direction unchanged by transformation (scaled by λ${i+1})
                    </div>
                `;
            });
            
            result.innerHTML = content;
        }
        
        function drawGrid(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 40;
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            for (let i = -10; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * scale, 0);
                ctx.lineTo(centerX + i * scale, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, centerY - i * scale);
                ctx.lineTo(canvas.width, centerY - i * scale);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        function drawAxes(ctx, canvas) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
        }
        
        function drawVector(ctx, canvas, vector, color, label, scale = 40) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const endX = centerX + vector[0] * scale;
            const endY = centerY - vector[1] * scale;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-vector[1], vector[0]);
            const arrowLength = 8;
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - arrowLength * Math.cos(angle - Math.PI/6), endY + arrowLength * Math.sin(angle - Math.PI/6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - arrowLength * Math.cos(angle + Math.PI/6), endY + arrowLength * Math.sin(angle + Math.PI/6));
            ctx.stroke();
            
            // Label
            ctx.fillStyle = color;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(label, endX + 5, endY - 5);
        }
        
        function drawTransformationVisualization() {
            transformCtx.clearRect(0, 0, transformCanvas.width, transformCanvas.height);
            drawGrid(transformCtx, transformCanvas);
            drawAxes(transformCtx, transformCanvas);
            
            // Draw unit grid vectors
            drawVector(transformCtx, transformCanvas, [1, 0], '#4ecdc4', 'i', 40);
            drawVector(transformCtx, transformCanvas, [0, 1], '#45b7d1', 'j', 40);
            
            // Draw some test vectors
            const testVectors = [[1, 1], [2, 0.5], [0.5, 2]];
            testVectors.forEach((v, i) => {
                drawVector(transformCtx, transformCanvas, v, '#999', `v${i+1}`, 40);
            });
            
            // Highlight eigenvectors if calculated
            if (eigenvectors.length > 0) {
                eigenvectors.forEach((v, i) => {
                    drawVector(transformCtx, transformCanvas, v, '#ff6b6b', `e${i+1}`, 40);
                });
            }
        }
        
        function showTransformation() {
            if (eigenvectors.length === 0) {
                calculateEigenvectors();
            }
            
            transformCtx.clearRect(0, 0, transformCanvas.width, transformCanvas.height);
            drawGrid(transformCtx, transformCanvas);
            drawAxes(transformCtx, transformCanvas);
            
            // Draw transformed vectors
            const testVectors = [[1, 0], [0, 1], [1, 1], [2, 0.5]];
            
            testVectors.forEach((v, i) => {
                // Apply transformation: Av
                const transformed = [
                    currentMatrix[0][0] * v[0] + currentMatrix[0][1] * v[1],
                    currentMatrix[1][0] * v[0] + currentMatrix[1][1] * v[1]
                ];
                
                // Draw original (light)
                drawVector(transformCtx, transformCanvas, v, 'rgba(150, 150, 150, 0.5)', '', 40);
                
                // Draw transformed (bold)
                drawVector(transformCtx, transformCanvas, transformed, '#2196F3', `Av${i+1}`, 40);
            });
            
            // Show eigenvectors and their transformations
            if (eigenvectors.length > 0 && eigenvalues.length > 0) {
                eigenvectors.forEach((v, i) => {
                    if (typeof eigenvalues[i] === 'number') {
                        const scaledEigenvector = [v[0] * eigenvalues[i], v[1] * eigenvalues[i]];
                        
                        // Original eigenvector
                        drawVector(transformCtx, transformCanvas, v, '#ff6b6b', `e${i+1}`, 40);
                        
                        // Scaled eigenvector
                        drawVector(transformCtx, transformCanvas, scaledEigenvector, '#ff0000', `λ${i+1}e${i+1}`, 40);
                    }
                });
            }
        }
        
        function animateTransformation() {
            let progress = 0;
            const maxProgress = 1;
            const speed = 0.02;
            
            function animate() {
                if (progress > maxProgress) return;
                
                transformCtx.clearRect(0, 0, transformCanvas.width, transformCanvas.height);
                drawGrid(transformCtx, transformCanvas);
                drawAxes(transformCtx, transformCanvas);
                
                const testVectors = [[1, 0], [0, 1], [1, 1]];
                
                testVectors.forEach((v, i) => {
                    // Interpolate between original and transformed
                    const transformed = [
                        currentMatrix[0][0] * v[0] + currentMatrix[0][1] * v[1],
                        currentMatrix[1][0] * v[0] + currentMatrix[1][1] * v[1]
                    ];
                    
                    const current = [
                        v[0] + progress * (transformed[0] - v[0]),
                        v[1] + progress * (transformed[1] - v[1])
                    ];
                    
                    drawVector(transformCtx, transformCanvas, current, '#2196F3', `v${i+1}`, 40);
                });
                
                progress += speed;
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function resetTransformation() {
            drawTransformationVisualization();
        }
        
        function showEigenvectors() {
            if (eigenvectors.length === 0) {
                calculateEigenvectors();
            }
            
            transformCtx.clearRect(0, 0, transformCanvas.width, transformCanvas.height);
            drawGrid(transformCtx, transformCanvas);
            drawAxes(transformCtx, transformCanvas);
            
            // Emphasize eigenvectors
            if (eigenvectors.length > 0) {
                eigenvectors.forEach((v, i) => {
                    // Draw extended line through eigenvector
                    const scale = 150;
                    transformCtx.strokeStyle = '#ff6b6b';
                    transformCtx.lineWidth = 2;
                    transformCtx.setLineDash([5, 5]);
                    
                    transformCtx.beginPath();
                    transformCtx.moveTo(transformCanvas.width/2 - v[0] * scale, transformCanvas.height/2 + v[1] * scale);
                    transformCtx.lineTo(transformCanvas.width/2 + v[0] * scale, transformCanvas.height/2 - v[1] * scale);
                    transformCtx.stroke();
                    
                    transformCtx.setLineDash([]);
                    
                    // Draw eigenvector
                    drawVector(transformCtx, transformCanvas, v, '#ff0000', `e${i+1} (λ=${eigenvalues[i]?.toFixed(2)})`, 40);
                });
            }
        }
        
        function generateData() {
            const spreadX = parseFloat(document.getElementById('spreadX').value);
            const spreadY = parseFloat(document.getElementById('spreadY').value);
            const correlation = parseFloat(document.getElementById('correlation').value);
            
            document.getElementById('spreadXValue').textContent = spreadX.toFixed(1);
            document.getElementById('spreadYValue').textContent = spreadY.toFixed(1);
            document.getElementById('correlationValue').textContent = correlation.toFixed(1);
            
            dataPoints = [];
            const numPoints = 50;
            
            for (let i = 0; i < numPoints; i++) {
                // Generate correlated Gaussian data
                const u1 = Math.random();
                const u2 = Math.random();
                
                const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
                
                const x = z1 * spreadX;
                const y = correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2;
                
                dataPoints.push([x, y * spreadY]);
            }
            
            drawPCAVisualization();
        }
        
        function drawPCAVisualization() {
            pcaCtx.clearRect(0, 0, pcaCanvas.width, pcaCanvas.height);
            drawGrid(pcaCtx, pcaCanvas);
            drawAxes(pcaCtx, pcaCanvas);
            
            // Draw data points
            const centerX = pcaCanvas.width / 2;
            const centerY = pcaCanvas.height / 2;
            const scale = 40;
            
            pcaCtx.fillStyle = '#2196F3';
            dataPoints.forEach(point => {
                const x = centerX + point[0] * scale;
                const y = centerY - point[1] * scale;
                
                pcaCtx.beginPath();
                pcaCtx.arc(x, y, 3, 0, 2 * Math.PI);
                pcaCtx.fill();
            });
        }
        
        function runPCA() {
            if (dataPoints.length === 0) {
                generateData();
            }
            
            // Center the data
            const meanX = dataPoints.reduce((sum, p) => sum + p[0], 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p[1], 0) / dataPoints.length;
            
            const centeredData = dataPoints.map(p => [p[0] - meanX, p[1] - meanY]);
            
            // Compute covariance matrix
            let cxx = 0, cxy = 0, cyy = 0;
            centeredData.forEach(p => {
                cxx += p[0] * p[0];
                cxy += p[0] * p[1];
                cyy += p[1] * p[1];
            });
            
            const n = centeredData.length - 1;
            cxx /= n;
            cxy /= n;
            cyy /= n;
            
            // Find eigenvalues of covariance matrix
            const trace = cxx + cyy;
            const det = cxx * cyy - cxy * cxy;
            const discriminant = trace * trace - 4 * det;
            
            const lambda1 = (trace + Math.sqrt(discriminant)) / 2;
            const lambda2 = (trace - Math.sqrt(discriminant)) / 2;
            
            // Find eigenvectors
            let v1, v2;
            if (Math.abs(cxy) > 0.001) {
                v1 = [1, (lambda1 - cxx) / cxy];
                v2 = [1, (lambda2 - cxx) / cxy];
            } else {
                v1 = [1, 0];
                v2 = [0, 1];
            }
            
            // Normalize eigenvectors
            const norm1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
            const norm2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
            v1 = [v1[0] / norm1, v1[1] / norm1];
            v2 = [v2[0] / norm2, v2[1] / norm2];
            
            pcaComponents = [
                { vector: v1, eigenvalue: lambda1 },
                { vector: v2, eigenvalue: lambda2 }
            ];
            
            // Draw PCA results
            drawPCAVisualization();
            
            // Draw principal components
            const scale = 40;
            pcaComponents.forEach((pc, i) => {
                const scaledVector = [
                    pc.vector[0] * Math.sqrt(pc.eigenvalue) * 2,
                    pc.vector[1] * Math.sqrt(pc.eigenvalue) * 2
                ];
                
                drawVector(pcaCtx, pcaCanvas, scaledVector, i === 0 ? '#ff6b6b' : '#ff9800', `PC${i+1}`, scale);
            });
            
            // Display results
            const totalVariance = lambda1 + lambda2;
            const variance1 = (lambda1 / totalVariance * 100).toFixed(1);
            const variance2 = (lambda2 / totalVariance * 100).toFixed(1);
            
            document.getElementById('pcaResults').innerHTML = `
                <strong>PCA Results:</strong><br>
                PC1: ${variance1}% variance (λ = ${lambda1.toFixed(3)})<br>
                PC2: ${variance2}% variance (λ = ${lambda2.toFixed(3)})<br>
                PC1 direction: [${v1[0].toFixed(3)}, ${v1[1].toFixed(3)}]<br>
                PC2 direction: [${v2[0].toFixed(3)}, ${v2[1].toFixed(3)}]
            `;
        }
        
        function projectData() {
            if (pcaComponents.length === 0) {
                runPCA();
            }
            
            // Project all data points onto PC1
            const pc1 = pcaComponents[0].vector;
            
            // Center the data first
            const meanX = dataPoints.reduce((sum, p) => sum + p[0], 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p[1], 0) / dataPoints.length;
            
            drawPCAVisualization();
            
            // Draw PC1 axis
            drawVector(pcaCtx, pcaCanvas, [pc1[0] * 3, pc1[1] * 3], '#ff6b6b', 'PC1', 40);
            
            // Project and draw projected points
            pcaCtx.fillStyle = '#4CAF50';
            dataPoints.forEach(point => {
                const centered = [point[0] - meanX, point[1] - meanY];
                
                // Project onto PC1
                const projection = (centered[0] * pc1[0] + centered[1] * pc1[1]);
                const projectedPoint = [projection * pc1[0], projection * pc1[1]];
                
                const x = pcaCanvas.width/2 + projectedPoint[0] * 40;
                const y = pcaCanvas.height/2 - projectedPoint[1] * 40;
                
                pcaCtx.beginPath();
                pcaCtx.arc(x, y, 3, 0, 2 * Math.PI);
                pcaCtx.fill();
            });
        }
        
        function clearPCA() {
            pcaCtx.clearRect(0, 0, pcaCanvas.width, pcaCanvas.height);
            drawGrid(pcaCtx, pcaCanvas);
            drawAxes(pcaCtx, pcaCanvas);
            
            document.getElementById('pcaResults').innerHTML = `
                <strong>PCA Results:</strong><br>
                Click "Generate Data" then "Run PCA" to analyze principal components.
            `;
        }
        
        function showDetailedCalculation() {
            updateMatrix();
            const a = currentMatrix[0][0];
            const b = currentMatrix[0][1];
            const c = currentMatrix[1][0];
            const d = currentMatrix[1][1];
            
            const content = `
                <h4>Step-by-Step Calculation for Current Matrix</h4>
                <div class="eigenvalue-item">
                    <strong>Matrix A = [${a}, ${b}; ${c}, ${d}]</strong>
                </div>
                <div class="eigenvalue-item">
                    <strong>Step 1:</strong> Characteristic equation<br>
                    det(A - λI) = det([${a}-λ, ${b}; ${c}, ${d}-λ]) = 0
                </div>
                <div class="eigenvalue-item">
                    <strong>Step 2:</strong> Expand determinant<br>
                    (${a}-λ)(${d}-λ) - (${b})(${c}) = 0<br>
                    λ² - ${a+d}λ + ${a*d - b*c} = 0
                </div>
                <div class="eigenvalue-item">
                    <strong>Step 3:</strong> Solve using quadratic formula<br>
                    λ = [${a+d} ± √(${(a+d)*(a+d)} - 4(${a*d - b*c}))] / 2<br>
                    λ = [${a+d} ± √${(a+d)*(a+d) - 4*(a*d - b*c)}] / 2
                </div>
            `;
            
            document.getElementById('stepByStep').innerHTML = content;
        }
        
        function showQuadraticFormula() {
            alert(`Quadratic Formula for Eigenvalues:

For matrix A = [a, b; c, d]
Characteristic equation: λ² - (a+d)λ + (ad-bc) = 0

Using quadratic formula:
λ = [(a+d) ± √((a+d)² - 4(ad-bc))] / 2

Where:
• a+d = trace of matrix
• ad-bc = determinant of matrix
• If discriminant < 0 → complex eigenvalues`);
        }
        
        function symmetricMatrix() {
            document.getElementById('a11').value = 2;
            document.getElementById('a12').value = 1;
            document.getElementById('a21').value = 1;
            document.getElementById('a22').value = 2;
            drawTransformationVisualization();
        }
        
        function randomMatrix() {
            document.getElementById('a11').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('a12').value = (Math.random() * 2 - 1).toFixed(1);
            document.getElementById('a21').value = (Math.random() * 2 - 1).toFixed(1);
            document.getElementById('a22').value = (Math.random() * 4 - 2).toFixed(1);
            drawTransformationVisualization();
        }
        
        // Exercise checking functions
        function checkExercise1() {
            const lambda1 = parseFloat(document.getElementById('ex1_lambda1').value);
            const lambda2 = parseFloat(document.getElementById('ex1_lambda2').value);
            
            const correct = (lambda1 === 4 && lambda2 === 2) || (lambda1 === 2 && lambda2 === 4);
            
            if (correct) {
                document.getElementById('ex1_feedback').innerHTML = ' <span style="color: #4CAF50;">✓ Correct! Diagonal entries are eigenvalues.</span>';
            } else {
                document.getElementById('ex1_feedback').innerHTML = ' <span style="color: #f44336;">✗ Try again. For diagonal matrices, look at the diagonal!</span>';
            }
        }
        
        function checkExercise2() {
            const x = parseFloat(document.getElementById('ex2_x').value);
            const y = parseFloat(document.getElementById('ex2_y').value);
            
            if (x === 3 && y === 0) {
                document.getElementById('ex2_feedback').innerHTML = ' <span style="color: #4CAF50;">✓ Correct! Av = λv = 3(1,0) = (3,0)</span>';
            } else {
                document.getElementById('ex2_feedback').innerHTML = ' <span style="color: #f44336;">✗ Try again. Use Av = λv formula.</span>';
            }
        }
        
        function checkExercise3(answer) {
            if (answer === 'pc1') {
                document.getElementById('ex3_feedback').innerHTML = ' <span style="color: #4CAF50;">✓ Correct! PC1 has the largest eigenvalue.</span>';
            } else {
                document.getElementById('ex3_feedback').innerHTML = ' <span style="color: #f44336;">✗ Wrong. Larger eigenvalue = more variance explained.</span>';
            }
        }
        
        function checkExercise4(answer) {
            if (answer === false) {
                document.getElementById('ex4_feedback').innerHTML = ' <span style="color: #4CAF50;">✓ Correct! Eigenvectors only get scaled, not rotated.</span>';
            } else {
                document.getElementById('ex4_feedback').innerHTML = ' <span style="color: #f44336;">✗ Wrong. Eigenvectors maintain their direction!</span>';
            }
        }
        
        function checkExercise5() {
            const det = parseFloat(document.getElementById('ex5_det').value);
            
            if (det === 10) {
                document.getElementById('ex5_feedback').innerHTML = ' <span style="color: #4CAF50;">✓ Correct! det = λ₁ × λ₂ = 5 × 2 = 10</span>';
            } else {
                document.getElementById('ex5_feedback').innerHTML = ' <span style="color: #f44336;">✗ Try again. Multiply the eigenvalues.</span>';
            }
        }
        
        // Event listeners for real-time updates
        ['a11', 'a12', 'a21', 'a22'].forEach(id => {
            document.getElementById(id).addEventListener('input', function() {
                drawTransformationVisualization();
                eigenvalues = [];
                eigenvectors = [];
            });
        });
        
        ['spreadX', 'spreadY', 'correlation'].forEach(id => {
            document.getElementById(id).addEventListener('input', function() {
                generateData();
            });
        });
        
        // Initialize
        window.addEventListener('load', function() {
            drawTransformationVisualization();
            generateData();
        });
    </script>
</body>
</html>
