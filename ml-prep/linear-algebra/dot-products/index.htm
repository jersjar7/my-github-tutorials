<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot Products & Orthogonality - Linear Algebra</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .header h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            color: #FFD700;
        }
        
        .header .breadcrumb {
            font-size: 1em;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .header .description {
            font-size: 1.2em;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .section h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-icon {
            font-size: 1.2em;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            color: #333;
        }
        
        .canvas-container h3 {
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            background: white;
            cursor: crosshair;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-bottom: 15px;
            color: #FFD700;
            font-size: 1.1em;
        }
        
        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .input-row label {
            min-width: 30px;
            font-weight: 500;
        }
        
        .input-row input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }
        
        .input-row input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .vector-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            text-align: center;
        }
        
        .dot-product-display {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .angle-display {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.5);
        }
        
        .orthogonal-display {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid rgba(255, 152, 0, 0.5);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }
        
        .btn-warning {
            background: linear-gradient(45deg, #FF9800, #f57c00);
        }
        
        .concept-explanation {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #FFD700;
            margin-bottom: 20px;
        }
        
        .concept-explanation h4 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .concept-explanation p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 10px 0;
            font-size: 1.1em;
        }
        
        .practice-section {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
        }
        
        .practice-section h3 {
            color: #FFD700;
            margin-bottom: 15px;
        }
        
        .exercise {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .exercise-question {
            font-weight: 500;
            margin-bottom: 10px;
        }
        
        .exercise-input {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .three-container {
            width: 100%;
            height: 400px;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .projection-display {
            background: rgba(156, 39, 176, 0.2);
            border: 1px solid rgba(156, 39, 176, 0.5);
            text-align: left;
            padding: 10px;
            font-size: 0.9em;
        }
        
        .angle-indicator {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
        }
        
        @media (max-width: 1024px) {
            .content-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .input-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-row label {
                min-width: auto;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="breadcrumb">ü§ñ ML Preparation ‚Ä∫ üìä Linear Algebra ‚Ä∫ üìê Dot Products & Orthogonality</div>
            <h1>Dot Products & Orthogonality</h1>
            <p class="description">
                Master the fundamental operation that connects geometry and algebra! The dot product reveals angles, measures similarity, and determines orthogonality - essential concepts for understanding ML algorithms like cosine similarity and gradient descent.
            </p>
        </div>
        
        <div class="content-grid">
            <div class="section">
                <h2><span class="section-icon">‚ö°</span>Dot Product Visualizer</h2>
                <div class="canvas-container">
                    <h3>Interactive Dot Product & Angle Calculator</h3>
                    <canvas id="dotProductCanvas" width="400" height="300"></canvas>
                    <p style="font-size: 0.9em; text-align: center; margin-top: 10px; color: #666;">
                        Drag vector endpoints to see how dot product and angle change
                    </p>
                </div>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <h3>Vector A</h3>
                        <div class="input-row">
                            <label>x:</label>
                            <input type="number" id="dotVectorA_x" placeholder="4" value="4" step="0.1">
                        </div>
                        <div class="input-row">
                            <label>y:</label>
                            <input type="number" id="dotVectorA_y" placeholder="2" value="2" step="0.1">
                        </div>
                        <div class="vector-display">A = (4.0, 2.0)</div>
                        <div class="vector-display">|A| = 4.47</div>
                    </div>
                    
                    <div class="control-group">
                        <h3>Vector B</h3>
                        <div class="input-row">
                            <label>x:</label>
                            <input type="number" id="dotVectorB_x" placeholder="2" value="2" step="0.1">
                        </div>
                        <div class="input-row">
                            <label>y:</label>
                            <input type="number" id="dotVectorB_y" placeholder="3" value="3" step="0.1">
                        </div>
                        <div class="vector-display">B = (2.0, 3.0)</div>
                        <div class="vector-display">|B| = 3.61</div>
                    </div>
                </div>
                
                <div class="vector-display dot-product-display" id="dotProductResult">
                    A ¬∑ B = 4√ó2 + 2√ó3 = 14
                </div>
                <div class="vector-display angle-display" id="angleResult">
                    Angle = 26.57¬∞
                </div>
                <div class="vector-display orthogonal-display" id="orthogonalStatus">
                    Vectors are NOT orthogonal
                </div>
                
                <div class="button-group">
                    <button class="btn" onclick="showProjection()">Show Projection</button>
                    <button class="btn btn-secondary" onclick="makeOrthogonal()">Make Orthogonal</button>
                    <button class="btn btn-warning" onclick="makeParallel()">Make Parallel</button>
                    <button class="btn btn-danger" onclick="resetDotVectors()">Reset</button>
                </div>
            </div>
            
            <div class="section">
                <h2><span class="section-icon">üìè</span>Vector Projection</h2>
                <div class="canvas-container">
                    <h3>Projection of A onto B</h3>
                    <canvas id="projectionCanvas" width="400" height="300"></canvas>
                    <p style="font-size: 0.9em; text-align: center; margin-top: 10px; color: #666;">
                        See how A "shadows" onto B
                    </p>
                </div>
                
                <div class="projection-display" id="projectionInfo">
                    <strong>Projection of A onto B:</strong><br>
                    proj_B(A) = [(A¬∑B)/|B|¬≤] √ó B<br>
                    Scalar projection = A¬∑B/|B| = 3.88<br>
                    Vector projection = (2.15, 3.23)
                </div>
                
                <div class="button-group">
                    <button class="btn" onclick="toggleProjectionDirection()">Project B onto A</button>
                    <button class="btn btn-secondary" onclick="showUnitVectors()">Show Unit Vectors</button>
                </div>
            </div>
        </div>
        
        <div class="content-grid">
            <div class="section">
                <h2><span class="section-icon">üßÆ</span>Dot Product Theory</h2>
                
                <div class="concept-explanation">
                    <h4>Algebraic Definition</h4>
                    <p>For vectors a = (a‚ÇÅ, a‚ÇÇ) and b = (b‚ÇÅ, b‚ÇÇ):</p>
                    <div class="formula">a ¬∑ b = a‚ÇÅb‚ÇÅ + a‚ÇÇb‚ÇÇ</div>
                    <p>Simply multiply corresponding components and add them up.</p>
                </div>
                
                <div class="concept-explanation">
                    <h4>Geometric Definition</h4>
                    <p>The dot product measures how much two vectors point in the same direction:</p>
                    <div class="formula">a ¬∑ b = |a| |b| cos(Œ∏)</div>
                    <p>Where Œ∏ is the angle between the vectors.</p>
                </div>
                
                <div class="concept-explanation">
                    <h4>Key Properties</h4>
                    <p>‚Ä¢ If a ¬∑ b > 0: vectors point in similar directions (acute angle)<br>
                       ‚Ä¢ If a ¬∑ b = 0: vectors are perpendicular (orthogonal)<br>
                       ‚Ä¢ If a ¬∑ b < 0: vectors point in opposite directions (obtuse angle)</p>
                </div>
            </div>
            
            <div class="section">
                <h2><span class="section-icon">‚ä•</span>Orthogonality</h2>
                
                <div class="concept-explanation">
                    <h4>What is Orthogonality?</h4>
                    <p>Two vectors are orthogonal (perpendicular) when their dot product equals zero.</p>
                    <div class="formula">a ‚ä• b ‚ü∫ a ¬∑ b = 0</div>
                    <p>This is fundamental in ML for feature independence and dimensionality reduction!</p>
                </div>
                
                <div class="concept-explanation">
                    <h4>ML Applications</h4>
                    <p><strong>Principal Component Analysis (PCA):</strong> Finds orthogonal directions of maximum variance.<br>
                    <strong>Gradient Descent:</strong> Step direction orthogonal to contour lines.<br>
                    <strong>Feature Engineering:</strong> Orthogonal features provide independent information.</p>
                </div>
                
                <div class="control-group">
                    <h3>Orthogonality Tester</h3>
                    <div class="input-row">
                        <label>Vector 1: (</label>
                        <input type="number" id="orth_v1_x" placeholder="3" value="3" step="0.1" style="width: 60px;">
                        <span>, </span>
                        <input type="number" id="orth_v1_y" placeholder="4" value="4" step="0.1" style="width: 60px;">
                        <span>)</span>
                    </div>
                    <div class="input-row">
                        <label>Vector 2: (</label>
                        <input type="number" id="orth_v2_x" placeholder="4" value="4" step="0.1" style="width: 60px;">
                        <span>, </span>
                        <input type="number" id="orth_v2_y" placeholder="-3" value="-3" step="0.1" style="width: 60px;">
                        <span>)</span>
                    </div>
                    <button class="btn" onclick="testOrthogonality()">Test Orthogonality</button>
                    <div class="vector-display orthogonal-display" id="orthTestResult">
                        Dot product = 0 ‚Üí Vectors are ORTHOGONAL! ‚ä•
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section full-width">
            <h2><span class="section-icon">üéØ</span>Practice Exercises</h2>
            <div class="practice-section">
                <h3>Test Your Understanding</h3>
                
                <div class="exercise">
                    <div class="exercise-question">1. Calculate the dot product of u = (3, -2) and v = (1, 4)</div>
                    <div class="exercise-input">
                        <span>u ¬∑ v = </span>
                        <input type="number" id="ex1_dot" placeholder="answer" style="width: 80px;">
                        <button class="btn" onclick="checkExercise1()">Check</button>
                        <span id="ex1_result"></span>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">2. What vector is orthogonal to (2, 3)?</div>
                    <div class="exercise-input">
                        <span>Orthogonal vector: (</span>
                        <input type="number" id="ex2_x" placeholder="x" style="width: 60px;">
                        <span>, </span>
                        <input type="number" id="ex2_y" placeholder="y" style="width: 60px;">
                        <span>)</span>
                        <button class="btn" onclick="checkExercise2()">Check</button>
                        <span id="ex2_result"></span>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">3. If |a| = 5, |b| = 3, and the angle between them is 60¬∞, what is a ¬∑ b?</div>
                    <div class="exercise-input">
                        <span>a ¬∑ b = </span>
                        <input type="number" id="ex3_dot" placeholder="answer" style="width: 80px;" step="0.1">
                        <button class="btn" onclick="checkExercise3()">Check</button>
                        <span id="ex3_result"></span>
                    </div>
                </div>
                
                <div class="exercise">
                    <div class="exercise-question">4. Find the angle between vectors (1, 0) and (1, 1)</div>
                    <div class="exercise-input">
                        <span>Angle = </span>
                        <input type="number" id="ex4_angle" placeholder="degrees" style="width: 80px;">
                        <span>¬∞</span>
                        <button class="btn" onclick="checkExercise4()">Check</button>
                        <span id="ex4_result"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Canvas setup for dot product visualization
        const dotCanvas = document.getElementById('dotProductCanvas');
        const dotCtx = dotCanvas.getContext('2d');
        const dotCenterX = dotCanvas.width / 2;
        const dotCenterY = dotCanvas.height / 2;
        const dotScale = 25;
        
        // Canvas setup for projection visualization
        const projCanvas = document.getElementById('projectionCanvas');
        const projCtx = projCanvas.getContext('2d');
        const projCenterX = projCanvas.width / 2;
        const projCenterY = projCanvas.height / 2;
        const projScale = 25;
        
        let dotVectorA = { x: 4, y: 2 };
        let dotVectorB = { x: 2, y: 3 };
        let showProjectionMode = false;
        let projectionDirection = 'A_onto_B'; // or 'B_onto_A'
        let isDragging = false;
        let dragTarget = null;
        
        function drawGrid(ctx, canvas, centerX, centerY, scale) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            for (let i = -10; i <= 10; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(centerX + i * scale, 0);
                ctx.lineTo(centerX + i * scale, canvas.height);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, centerY - i * scale);
                ctx.lineTo(canvas.width, centerY - i * scale);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        function drawAxes(ctx, canvas, centerX, centerY) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
        }
        
        function drawVector(ctx, vector, color, label, centerX, centerY, scale, offset = { x: 0, y: 0 }) {
            const startX = centerX + offset.x * scale;
            const startY = centerY - offset.y * scale;
            const endX = startX + vector.x * scale;
            const endY = startY - vector.y * scale;
            
            // Draw vector line
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw vector head as dot
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw starting point
            ctx.beginPath();
            ctx.arc(startX, startY, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw label
            ctx.fillStyle = color;
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, endX + 8, endY - 8);
            
            return { startX, startY, endX, endY };
        }
        
        function drawAngleArc(ctx, vectorA, vectorB, centerX, centerY, scale) {
            const angleA = Math.atan2(-vectorA.y, vectorA.x);
            const angleB = Math.atan2(-vectorB.y, vectorB.x);
            
            let startAngle = Math.min(angleA, angleB);
            let endAngle = Math.max(angleA, angleB);
            
            // Handle angle wrap-around
            if (endAngle - startAngle > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle + 2 * Math.PI];
            }
            
            const arcRadius = 30;
            
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, arcRadius, startAngle, endAngle);
            ctx.stroke();
            
            // Draw angle label
            const midAngle = (startAngle + endAngle) / 2;
            const labelX = centerX + Math.cos(midAngle) * (arcRadius + 15);
            const labelY = centerY - Math.sin(midAngle) * (arcRadius + 15);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            const angle = Math.abs(endAngle - startAngle) * 180 / Math.PI;
            ctx.fillText(`${angle.toFixed(1)}¬∞`, labelX, labelY);
            ctx.textAlign = 'left';
        }
        
        function drawDotProductVisualization() {
            dotCtx.clearRect(0, 0, dotCanvas.width, dotCanvas.height);
            drawGrid(dotCtx, dotCanvas, dotCenterX, dotCenterY, dotScale);
            drawAxes(dotCtx, dotCanvas, dotCenterX, dotCenterY);
            
            // Draw vectors
            const aPos = drawVector(dotCtx, dotVectorA, '#ff6b6b', 'A', dotCenterX, dotCenterY, dotScale);
            const bPos = drawVector(dotCtx, dotVectorB, '#4ecdc4', 'B', dotCenterX, dotCenterY, dotScale);
            
            // Draw angle arc
            drawAngleArc(dotCtx, dotVectorA, dotVectorB, dotCenterX, dotCenterY, dotScale);
            
            return { aPos, bPos };
        }
        
        function drawProjectionVisualization() {
            projCtx.clearRect(0, 0, projCanvas.width, projCanvas.height);
            drawGrid(projCtx, projCanvas, projCenterX, projCenterY, projScale);
            drawAxes(projCtx, projCanvas, projCenterX, projCenterY);
            
            // Draw original vectors
            drawVector(projCtx, dotVectorA, '#ff6b6b', 'A', projCenterX, projCenterY, projScale);
            drawVector(projCtx, dotVectorB, '#4ecdc4', 'B', projCenterX, projCenterY, projScale);
            
            // Calculate and draw projection
            let projVector, projColor, projLabel;
            
            if (projectionDirection === 'A_onto_B') {
                // Project A onto B
                const dotProduct = dotVectorA.x * dotVectorB.x + dotVectorA.y * dotVectorB.y;
                const bMagnitudeSquared = dotVectorB.x * dotVectorB.x + dotVectorB.y * dotVectorB.y;
                const scalar = dotProduct / bMagnitudeSquared;
                
                projVector = { x: scalar * dotVectorB.x, y: scalar * dotVectorB.y };
                projColor = '#9c27b0';
                projLabel = 'proj_B(A)';
            } else {
                // Project B onto A
                const dotProduct = dotVectorA.x * dotVectorB.x + dotVectorA.y * dotVectorB.y;
                const aMagnitudeSquared = dotVectorA.x * dotVectorA.x + dotVectorA.y * dotVectorA.y;
                const scalar = dotProduct / aMagnitudeSquared;
                
                projVector = { x: scalar * dotVectorA.x, y: scalar * dotVectorA.y };
                projColor = '#9c27b0';
                projLabel = 'proj_A(B)';
            }
            
            // Draw projection vector
            drawVector(projCtx, projVector, projColor, projLabel, projCenterX, projCenterY, projScale);
            
            // Draw projection lines (dotted)
            projCtx.strokeStyle = 'rgba(156, 39, 176, 0.5)';
            projCtx.lineWidth = 2;
            projCtx.setLineDash([5, 5]);
            
            if (projectionDirection === 'A_onto_B') {
                const projEndX = projCenterX + projVector.x * projScale;
                const projEndY = projCenterY - projVector.y * projScale;
                const aEndX = projCenterX + dotVectorA.x * projScale;
                const aEndY = projCenterY - dotVectorA.y * projScale;
                
                projCtx.beginPath();
                projCtx.moveTo(projEndX, projEndY);
                projCtx.lineTo(aEndX, aEndY);
                projCtx.stroke();
            } else {
                const projEndX = projCenterX + projVector.x * projScale;
                const projEndY = projCenterY - projVector.y * projScale;
                const bEndX = projCenterX + dotVectorB.x * projScale;
                const bEndY = projCenterY - dotVectorB.y * projScale;
                
                projCtx.beginPath();
                projCtx.moveTo(projEndX, projEndY);
                projCtx.lineTo(bEndX, bEndY);
                projCtx.stroke();
            }
            
            projCtx.setLineDash([]);
        }
        
        function updateDotProductDisplays() {
            const dotProduct = dotVectorA.x * dotVectorB.x + dotVectorA.y * dotVectorB.y;
            const magA = Math.sqrt(dotVectorA.x * dotVectorA.x + dotVectorA.y * dotVectorA.y);
            const magB = Math.sqrt(dotVectorB.x * dotVectorB.x + dotVectorB.y * dotVectorB.y);
            
            // Calculate angle
            const cosTheta = dotProduct / (magA * magB);
            const theta = Math.acos(Math.max(-1, Math.min(1, cosTheta))) * 180 / Math.PI;
            
            // Update displays
            document.querySelector('.control-group:nth-child(1) .vector-display:nth-child(4)').textContent = `A = (${dotVectorA.x.toFixed(1)}, ${dotVectorA.y.toFixed(1)})`;
            document.querySelector('.control-group:nth-child(1) .vector-display:nth-child(5)').textContent = `|A| = ${magA.toFixed(2)}`;
            document.querySelector('.control-group:nth-child(2) .vector-display:nth-child(4)').textContent = `B = (${dotVectorB.x.toFixed(1)}, ${dotVectorB.y.toFixed(1)})`;
            document.querySelector('.control-group:nth-child(2) .vector-display:nth-child(5)').textContent = `|B| = ${magB.toFixed(2)}`;
            
            document.getElementById('dotProductResult').textContent = `A ¬∑ B = ${dotVectorA.x}√ó${dotVectorB.x} + ${dotVectorA.y}√ó${dotVectorB.y} = ${dotProduct.toFixed(2)}`;
            document.getElementById('angleResult').textContent = `Angle = ${theta.toFixed(2)}¬∞`;
            
            // Orthogonality check
            const isOrthogonal = Math.abs(dotProduct) < 0.01;
            document.getElementById('orthogonalStatus').textContent = isOrthogonal ? 
                'Vectors are ORTHOGONAL! ‚ä•' : 'Vectors are NOT orthogonal';
            document.getElementById('orthogonalStatus').style.background = isOrthogonal ? 
                'rgba(76, 175, 80, 0.3)' : 'rgba(255, 152, 0, 0.2)';
            
            // Update projection info
            updateProjectionDisplay();
        }
        
        function updateProjectionDisplay() {
            const dotProduct = dotVectorA.x * dotVectorB.x + dotVectorA.y * dotVectorB.y;
            const magB = Math.sqrt(dotVectorB.x * dotVectorB.x + dotVectorB.y * dotVectorB.y);
            const magBSquared = dotVectorB.x * dotVectorB.x + dotVectorB.y * dotVectorB.y;
            
            const scalarProj = dotProduct / magB;
            const projVector = { 
                x: (dotProduct / magBSquared) * dotVectorB.x, 
                y: (dotProduct / magBSquared) * dotVectorB.y 
            };
            
            document.getElementById('projectionInfo').innerHTML = `
                <strong>Projection of A onto B:</strong><br>
                proj_B(A) = [(A¬∑B)/|B|¬≤] √ó B<br>
                Scalar projection = A¬∑B/|B| = ${scalarProj.toFixed(2)}<br>
                Vector projection = (${projVector.x.toFixed(2)}, ${projVector.y.toFixed(2)})
            `;
        }
        
        function showProjection() {
            showProjectionMode = !showProjectionMode;
            if (showProjectionMode) {
                drawProjectionVisualization();
            } else {
                drawDotProductVisualization();
            }
        }
        
        function makeOrthogonal() {
            // Make B orthogonal to A by setting B to (-A.y, A.x)
            dotVectorB.x = -dotVectorA.y;
            dotVectorB.y = dotVectorA.x;
            
            document.getElementById('dotVectorB_x').value = dotVectorB.x.toFixed(1);
            document.getElementById('dotVectorB_y').value = dotVectorB.y.toFixed(1);
            
            updateDotProductDisplays();
            drawDotProductVisualization();
        }
        
        function makeParallel() {
            // Make B parallel to A
            const ratio = Math.sqrt(dotVectorB.x * dotVectorB.x + dotVectorB.y * dotVectorB.y) / 
                         Math.sqrt(dotVectorA.x * dotVectorA.x + dotVectorA.y * dotVectorA.y);
            
            dotVectorB.x = dotVectorA.x * ratio;
            dotVectorB.y = dotVectorA.y * ratio;
            
            document.getElementById('dotVectorB_x').value = dotVectorB.x.toFixed(1);
            document.getElementById('dotVectorB_y').value = dotVectorB.y.toFixed(1);
            
            updateDotProductDisplays();
            drawDotProductVisualization();
        }
        
        function resetDotVectors() {
            dotVectorA = { x: 4, y: 2 };
            dotVectorB = { x: 2, y: 3 };
            
            document.getElementById('dotVectorA_x').value = dotVectorA.x;
            document.getElementById('dotVectorA_y').value = dotVectorA.y;
            document.getElementById('dotVectorB_x').value = dotVectorB.x;
            document.getElementById('dotVectorB_y').value = dotVectorB.y;
            
            updateDotProductDisplays();
            drawDotProductVisualization();
        }
        
        function toggleProjectionDirection() {
            projectionDirection = projectionDirection === 'A_onto_B' ? 'B_onto_A' : 'A_onto_B';
            drawProjectionVisualization();
            updateProjectionDisplay();
        }
        
        function showUnitVectors() {
            const magA = Math.sqrt(dotVectorA.x * dotVectorA.x + dotVectorA.y * dotVectorA.y);
            const magB = Math.sqrt(dotVectorB.x * dotVectorB.x + dotVectorB.y * dotVectorB.y);
            
            const unitA = { x: dotVectorA.x / magA, y: dotVectorA.y / magA };
            const unitB = { x: dotVectorB.x / magB, y: dotVectorB.y / magB };
            
            alert(`Unit vector A: (${unitA.x.toFixed(3)}, ${unitA.y.toFixed(3)})\nUnit vector B: (${unitB.x.toFixed(3)}, ${unitB.y.toFixed(3)})\nDot product of unit vectors: ${(unitA.x * unitB.x + unitA.y * unitB.y).toFixed(3)}`);
        }
        
        function testOrthogonality() {
            const v1x = parseFloat(document.getElementById('orth_v1_x').value) || 0;
            const v1y = parseFloat(document.getElementById('orth_v1_y').value) || 0;
            const v2x = parseFloat(document.getElementById('orth_v2_x').value) || 0;
            const v2y = parseFloat(document.getElementById('orth_v2_y').value) || 0;
            
            const dotProduct = v1x * v2x + v1y * v2y;
            const isOrthogonal = Math.abs(dotProduct) < 0.01;
            
            document.getElementById('orthTestResult').textContent = isOrthogonal ? 
                `Dot product = ${dotProduct.toFixed(2)} ‚Üí Vectors are ORTHOGONAL! ‚ä•` :
                `Dot product = ${dotProduct.toFixed(2)} ‚Üí Vectors are NOT orthogonal`;
            
            document.getElementById('orthTestResult').style.background = isOrthogonal ? 
                'rgba(76, 175, 80, 0.3)' : 'rgba(255, 152, 0, 0.2)';
        }
        
        // Exercise checking functions
        function checkExercise1() {
            const userAnswer = parseFloat(document.getElementById('ex1_dot').value);
            const correct = 3 * 1 + (-2) * 4; // = -5
            
            if (Math.abs(userAnswer - correct) < 0.1) {
                document.getElementById('ex1_result').innerHTML = ' <span style="color: #4CAF50;">‚úì Correct!</span>';
            } else {
                document.getElementById('ex1_result').innerHTML = ' <span style="color: #f44336;">‚úó Try again (hint: 3√ó1 + (-2)√ó4)</span>';
            }
        }
        
        function checkExercise2() {
            const userX = parseFloat(document.getElementById('ex2_x').value);
            const userY = parseFloat(document.getElementById('ex2_y').value);
            
            // Check if dot product with (2,3) equals zero
            const dotProduct = 2 * userX + 3 * userY;
            
            if (Math.abs(dotProduct) < 0.1) {
                document.getElementById('ex2_result').innerHTML = ' <span style="color: #4CAF50;">‚úì Correct! (Many answers possible)</span>';
            } else {
                document.getElementById('ex2_result').innerHTML = ' <span style="color: #f44336;">‚úó Try again (hint: 2x + 3y = 0)</span>';
            }
        }
        
        function checkExercise3() {
            const userAnswer = parseFloat(document.getElementById('ex3_dot').value);
            const correct = 5 * 3 * Math.cos(60 * Math.PI / 180); // = 7.5
            
            if (Math.abs(userAnswer - correct) < 0.1) {
                document.getElementById('ex3_result').innerHTML = ' <span style="color: #4CAF50;">‚úì Correct!</span>';
            } else {
                document.getElementById('ex3_result').innerHTML = ' <span style="color: #f44336;">‚úó Try again (hint: cos(60¬∞) = 0.5)</span>';
            }
        }
        
        function checkExercise4() {
            const userAnswer = parseFloat(document.getElementById('ex4_angle').value);
            const correct = 45; // angle between (1,0) and (1,1) is 45¬∞
            
            if (Math.abs(userAnswer - correct) < 1) {
                document.getElementById('ex4_result').innerHTML = ' <span style="color: #4CAF50;">‚úì Correct!</span>';
            } else {
                document.getElementById('ex4_result').innerHTML = ' <span style="color: #f44336;">‚úó Try again (hint: use arccos(dot product / (|a||b|)))</span>';
            }
        }
        
        // Event listeners for input changes
        document.getElementById('dotVectorA_x').addEventListener('input', function() {
            dotVectorA.x = parseFloat(this.value) || 0;
            updateDotProductDisplays();
            drawDotProductVisualization();
        });
        
        document.getElementById('dotVectorA_y').addEventListener('input', function() {
            dotVectorA.y = parseFloat(this.value) || 0;
            updateDotProductDisplays();
            drawDotProductVisualization();
        });
        
        document.getElementById('dotVectorB_x').addEventListener('input', function() {
            dotVectorB.x = parseFloat(this.value) || 0;
            updateDotProductDisplays();
            drawDotProductVisualization();
        });
        
        document.getElementById('dotVectorB_y').addEventListener('input', function() {
            dotVectorB.y = parseFloat(this.value) || 0;
            updateDotProductDisplays();
            drawDotProductVisualization();
        });
        
        // Canvas drag interaction
        function getMousePos(canvas, e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function isNearPoint(mousePos, pointX, pointY, threshold = 15) {
            const dx = mousePos.x - pointX;
            const dy = mousePos.y - pointY;
            return Math.sqrt(dx * dx + dy * dy) < threshold;
        }
        
        dotCanvas.addEventListener('mousedown', function(e) {
            const mousePos = getMousePos(dotCanvas, e);
            
            const aEndX = dotCenterX + dotVectorA.x * dotScale;
            const aEndY = dotCenterY - dotVectorA.y * dotScale;
            const bEndX = dotCenterX + dotVectorB.x * dotScale;
            const bEndY = dotCenterY - dotVectorB.y * dotScale;
            
            if (isNearPoint(mousePos, aEndX, aEndY)) {
                isDragging = true;
                dragTarget = 'A';
            } else if (isNearPoint(mousePos, bEndX, bEndY)) {
                isDragging = true;
                dragTarget = 'B';
            }
        });
        
        dotCanvas.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const mousePos = getMousePos(dotCanvas, e);
            const vectorX = (mousePos.x - dotCenterX) / dotScale;
            const vectorY = -(mousePos.y - dotCenterY) / dotScale;
            
            if (dragTarget === 'A') {
                dotVectorA.x = vectorX;
                dotVectorA.y = vectorY;
                document.getElementById('dotVectorA_x').value = vectorX.toFixed(1);
                document.getElementById('dotVectorA_y').value = vectorY.toFixed(1);
            } else if (dragTarget === 'B') {
                dotVectorB.x = vectorX;
                dotVectorB.y = vectorY;
                document.getElementById('dotVectorB_x').value = vectorX.toFixed(1);
                document.getElementById('dotVectorB_y').value = vectorY.toFixed(1);
            }
            
            updateDotProductDisplays();
            drawDotProductVisualization();
        });
        
        dotCanvas.addEventListener('mouseup', function() {
            isDragging = false;
            dragTarget = null;
        });
        
        // Initialize everything
        window.addEventListener('load', function() {
            updateDotProductDisplays();
            drawDotProductVisualization();
            testOrthogonality();
        });
    </script>
</body>
</html>
